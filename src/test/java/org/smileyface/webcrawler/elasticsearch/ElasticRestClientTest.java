package org.smileyface.webcrawler.elasticsearch;

import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.elasticsearch.core.GetResponse;
import co.elastic.clients.json.jackson.JacksonJsonpMapper;
import co.elastic.clients.transport.ElasticsearchTransport;
import co.elastic.clients.transport.rest_client.RestClientTransport;
import org.elasticsearch.client.RestClient;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assumptions;
import org.smileyface.webcrawler.model.WebPageContent;
import org.smileyface.webcrawler.testutil.ElasticsearchTestContainer;

import java.io.IOException;
import java.util.List;
import java.util.UUID;

import static org.assertj.core.api.Assertions.*;

/**
 * Integration tests for ElasticRestClient#indexDocument using a real Elasticsearch Testcontainer.
 * Tests are skipped automatically if Docker is not available.
 */
class ElasticRestClientTest {

    private static boolean dockerAvailable;
    private static RestClient lowLevel;
    private static ElasticsearchClient validationClient;
    private static ElasticRestClient es;

    @BeforeAll
    static void setup() {
        try {
            ElasticsearchTestContainer.start();
            dockerAvailable = true;

            String hostPort = ElasticsearchTestContainer.getHttpHostAddress(); // host:port
            lowLevel = RestClient.builder(org.apache.http.HttpHost.create("http://" + hostPort)).build();
            ElasticsearchTransport transport = new RestClientTransport(lowLevel, new JacksonJsonpMapper());
            validationClient = new ElasticsearchClient(transport);
            String[] parts = hostPort.split(":");
            String host = parts[0];
            int port = Integer.parseInt(parts[1]);
            es = new ElasticRestClient(new ElasticContext("test", host, port));
        } catch (Throwable t) {
            dockerAvailable = false;
        }
    }

    @AfterAll
    static void tearDown() throws IOException {
        if (lowLevel != null) {
            lowLevel.close();
            lowLevel = null;
        }
        if (dockerAvailable) {
            ElasticsearchTestContainer.stop();
        }
    }

    @Test
    void indexDocument_withProvidedId_indexesAndReturnsSameId() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("test_index_" + UUID.randomUUID()).toLowerCase();
        boolean created = es.createIndex(index);
        assertThat(created).as("Index should be created for test").isTrue();

        WebPageContent doc = new WebPageContent();
        String id = "doc-" + UUID.randomUUID();
        String url = "https://example.com/" + id;
        doc.setId(id);
        doc.setUrl(url);
        doc.setContents(List.of("hello", "world"));
        // Do not set Instant fields to avoid requiring Jackson JavaTimeModule in this test

        String returnedId = es.indexDocument(index, doc);
        assertThat(returnedId).as("Returned id should equal provided id").isEqualTo(id);

        GetResponse<WebPageContent> get = validationClient.get(g -> g.index(index).id(returnedId), WebPageContent.class);
        assertThat(get.found()).as("Indexed document should be retrievable by id").isTrue();
        assertThat(get.source()).isNotNull();
        assertThat(get.source().getUrl()).isEqualTo(url);
    }

    @Test
    void indexDocument_autoGeneratedId_returnsNonBlank_andDocRetrievable() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("test_index_" + UUID.randomUUID()).toLowerCase();
        boolean created = es.createIndex(index);
        assertThat(created).as("Index should be created for test").isTrue();

        WebPageContent doc = new WebPageContent();
        String url = "https://autogen.example/" + UUID.randomUUID();
        doc.setUrl(url);
        doc.setContents(List.of("auto-id"));
        // Do not set Instant fields to avoid requiring Jackson JavaTimeModule in this test

        String returnedId = es.indexDocument(index, doc);
        assertThat(returnedId).isNotNull();
        assertThat(returnedId.isBlank()).isFalse();

        GetResponse<WebPageContent> get = validationClient.get(g -> g.index(index).id(returnedId), WebPageContent.class);
        assertThat(get.found()).isTrue();
        assertThat(get.source().getUrl()).isEqualTo(url);
    }

    @Test
    void indexDocument_invalidArgs_throwIllegalArgumentException() throws IOException {
        // This test does not require Docker. Pass a null client because the method should short-circuit on validation
        // before attempting to use the underlying Elasticsearch client.
        ElasticRestClient localEs = new ElasticRestClient(new ElasticContext("default", "localhost", 9200));

        WebPageContent doc = new WebPageContent();
        doc.setUrl("https://x");
        doc.setContents(List.of("y"));

        assertThatThrownBy(() -> localEs.indexDocument(null, doc)).isInstanceOf(IllegalArgumentException.class);
        assertThatThrownBy(() -> localEs.indexDocument("  ", doc)).isInstanceOf(IllegalArgumentException.class);
        assertThatThrownBy(() -> localEs.indexDocument("idx", null)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    void createIndex_returnsTrueThenFalse_andExists() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("idx_" + UUID.randomUUID()).toLowerCase();
        boolean created1 = es.createIndex(index);
        boolean created2 = es.createIndex(index);

        assertThat(created1).as("First creation should create the index").isTrue();
        assertThat(created2).as("Second creation should return false (already exists)").isFalse();

        boolean exists = validationClient.indices().exists(b -> b.index(index)).value();
        assertThat(exists).as("Index should exist in cluster").isTrue();
    }

    @Test
    void deleteIndex_deletesAndIsIdempotent() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("idx_del_" + UUID.randomUUID()).toLowerCase();
        assertThat(es.createIndex(index)).isTrue();
        assertThat(validationClient.indices().exists(b -> b.index(index)).value()).isTrue();

        boolean deleted1 = es.deleteIndex(index);
        boolean deleted2 = es.deleteIndex(index);

        assertThat(deleted1).as("Existing index should be deleted").isTrue();
        assertThat(deleted2).as("Deleting again should return false (not found)").isFalse();
        assertThat(validationClient.indices().exists(b -> b.index(index)).value()).isFalse();
    }

    @Test
    void createAlias_and_deleteAlias_work() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("idx_alias_" + UUID.randomUUID()).toLowerCase();
        String alias = ("alias_" + UUID.randomUUID()).toLowerCase();
        assertThat(es.createIndex(index)).isTrue();

        // Create alias and verify it exists
        es.createAlias(index, alias);
        boolean aliasExists = validationClient.indices().existsAlias(b -> b.index(index).name(alias)).value();
        assertThat(aliasExists).as("Alias should exist for index").isTrue();

        // Index a document via alias to ensure alias is usable for writes
        WebPageContent doc = new WebPageContent();
        String url = "https://alias.example/" + UUID.randomUUID();
        doc.setUrl(url);
        doc.setContents(List.of("via-alias"));
        String id = es.indexDocument(alias, doc);
        assertThat(id).isNotNull();

        GetResponse<WebPageContent> fetched = validationClient.get(g -> g.index(index).id(id), WebPageContent.class);
        assertThat(fetched.found()).isTrue();
        assertThat(fetched.source().getUrl()).isEqualTo(url);

        // Delete alias and verify it no longer exists
        es.deleteAlias(index, alias);
        boolean aliasExistsAfter = validationClient.indices().existsAlias(b -> b.index(index).name(alias)).value();
        assertThat(aliasExistsAfter).as("Alias should be removed from index").isFalse();
    }

    @Test
    void createIndex_withJsonBody_appliesAlias() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("idx_body_" + UUID.randomUUID()).toLowerCase();
        String alias = ("alias_body_" + UUID.randomUUID()).toLowerCase();

        String json = "{" +
                "\"aliases\": {\"" + alias + "\": {}}" +
                "}";

        boolean created = es.createIndex(index, json);
        assertThat(created).as("Index should be created with JSON body").isTrue();

        boolean aliasExists = validationClient.indices().existsAlias(b -> b.index(index).name(alias)).value();
        assertThat(aliasExists).as("Alias from JSON body should be applied to index").isTrue();
    }

    @Test
    void createTemplate_patternsOnly_thenDelete() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String template = ("tmpl_" + UUID.randomUUID()).toLowerCase();
        List<String> patterns = List.of("logs-" + UUID.randomUUID().toString().substring(0, 8) + "-*");

        es.createTemplate(template, patterns, null);
        boolean exists = validationClient.indices().existsIndexTemplate(b -> b.name(template)).value();
        assertThat(exists).as("Template should exist after creation").isTrue();

        es.deleteTemplate(template);
        boolean existsAfter = validationClient.indices().existsIndexTemplate(b -> b.name(template)).value();
        assertThat(existsAfter).as("Template should be deleted").isFalse();
    }

    @Test
    void createTemplate_withJson_appliesAliasOnNewIndex() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String template = ("tmpl_json_" + UUID.randomUUID()).toLowerCase();
        String prefix = ("data-" + UUID.randomUUID().toString().substring(0, 8)).toLowerCase();
        String alias = ("tmpl_alias_" + UUID.randomUUID()).toLowerCase();
        List<String> patterns = List.of(prefix + "-*");

        String templateJson = "{" +
                "\"index_patterns\": [\"" + patterns.get(0) + "\"]," +
                "\"template\": {" +
                "\"aliases\": {\"" + alias + "\": {}}" +
                "}" +
                "}";

        es.createTemplate(template, patterns, templateJson);
        boolean exists = validationClient.indices().existsIndexTemplate(b -> b.name(template)).value();
        assertThat(exists).as("Template should exist after creation").isTrue();

        // Create an index that matches the template and verify alias is applied
        String index = prefix + "-0001";
        boolean created = es.createIndex(index);
        assertThat(created).isTrue();

        boolean aliasExists = validationClient.indices().existsAlias(b -> b.index(index).name(alias)).value();
        assertThat(aliasExists).as("Alias defined in template should be applied to the created index").isTrue();

        // Cleanup template
        es.deleteTemplate(template);
    }
}
