package org.smileyface.webcrawler.elasticsearch;

import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.elasticsearch.core.GetResponse;
import co.elastic.clients.json.jackson.JacksonJsonpMapper;
import co.elastic.clients.transport.ElasticsearchTransport;
import co.elastic.clients.transport.rest_client.RestClientTransport;
import org.elasticsearch.client.RestClient;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assumptions;
import org.smileyface.webcrawler.model.WebPageContent;
import org.smileyface.webcrawler.testutil.ElasticsearchTestContainer;

import java.io.IOException;
import java.util.List;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests for ElasticRestClient#indexDocument using a real Elasticsearch Testcontainer.
 * Tests are skipped automatically if Docker is not available.
 */
class ElasticRestClientTest {

    private static boolean dockerAvailable;
    private static RestClient lowLevel;
    private static ElasticsearchClient validationClient;
    private static ElasticRestClient es;

    @BeforeAll
    static void setup() {
        try {
            ElasticsearchTestContainer.start();
            dockerAvailable = true;

            String hostPort = ElasticsearchTestContainer.getHttpHostAddress(); // host:port
            lowLevel = RestClient.builder(org.apache.http.HttpHost.create("http://" + hostPort)).build();
            ElasticsearchTransport transport = new RestClientTransport(lowLevel, new JacksonJsonpMapper());
            validationClient = new ElasticsearchClient(transport);
            String[] parts = hostPort.split(":");
            String host = parts[0];
            int port = Integer.parseInt(parts[1]);
            es = new ElasticRestClient(new ElasticContext("test", host, port));
        } catch (Throwable t) {
            dockerAvailable = false;
        }
    }

    @AfterAll
    static void tearDown() throws IOException {
        if (lowLevel != null) {
            lowLevel.close();
            lowLevel = null;
        }
        if (dockerAvailable) {
            ElasticsearchTestContainer.stop();
        }
    }

    @Test
    void indexDocument_withProvidedId_indexesAndReturnsSameId() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("test_index_" + UUID.randomUUID()).toLowerCase();
        boolean created = es.createIndex(index);
        assertTrue(created, "Index should be created for test");

        WebPageContent doc = new WebPageContent();
        String id = "doc-" + UUID.randomUUID();
        String url = "https://example.com/" + id;
        doc.setId(id);
        doc.setUrl(url);
        doc.setContents(List.of("hello", "world"));
        // Do not set Instant fields to avoid requiring Jackson JavaTimeModule in this test

        String returnedId = es.indexDocument(index, doc);
        assertEquals(id, returnedId, "Returned id should equal provided id");

        GetResponse<WebPageContent> get = validationClient.get(g -> g.index(index).id(returnedId), WebPageContent.class);
        assertTrue(get.found(), "Indexed document should be retrievable by id");
        assertNotNull(get.source());
        assertEquals(url, get.source().getUrl());
    }

    @Test
    void indexDocument_autoGeneratedId_returnsNonBlank_andDocRetrievable() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("test_index_" + UUID.randomUUID()).toLowerCase();
        boolean created = es.createIndex(index);
        assertTrue(created, "Index should be created for test");

        WebPageContent doc = new WebPageContent();
        String url = "https://autogen.example/" + UUID.randomUUID();
        doc.setUrl(url);
        doc.setContents(List.of("auto-id"));
        // Do not set Instant fields to avoid requiring Jackson JavaTimeModule in this test

        String returnedId = es.indexDocument(index, doc);
        assertNotNull(returnedId);
        assertFalse(returnedId.isBlank());

        GetResponse<WebPageContent> get = validationClient.get(g -> g.index(index).id(returnedId), WebPageContent.class);
        assertTrue(get.found());
        assertEquals(url, get.source().getUrl());
    }

    @Test
    void indexDocument_invalidArgs_throwIllegalArgumentException() throws IOException {
        // This test does not require Docker. Pass a null client because the method should short-circuit on validation
        // before attempting to use the underlying Elasticsearch client.
        ElasticRestClient localEs = new ElasticRestClient(new ElasticContext("default", "localhost", 9200));

        WebPageContent doc = new WebPageContent();
        doc.setUrl("https://x");
        doc.setContents(List.of("y"));

        assertThrows(IllegalArgumentException.class, () -> localEs.indexDocument(null, doc));
        assertThrows(IllegalArgumentException.class, () -> localEs.indexDocument("  ", doc));
        assertThrows(IllegalArgumentException.class, () -> localEs.indexDocument("idx", null));
    }

    @Test
    void createIndex_returnsTrueThenFalse_andExists() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("idx_" + UUID.randomUUID()).toLowerCase();
        boolean created1 = es.createIndex(index);
        boolean created2 = es.createIndex(index);

        assertTrue(created1, "First creation should create the index");
        assertFalse(created2, "Second creation should return false (already exists)");

        boolean exists = validationClient.indices().exists(b -> b.index(index)).value();
        assertTrue(exists, "Index should exist in cluster");
    }

    @Test
    void deleteIndex_deletesAndIsIdempotent() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("idx_del_" + UUID.randomUUID()).toLowerCase();
        assertTrue(es.createIndex(index));
        assertTrue(validationClient.indices().exists(b -> b.index(index)).value());

        boolean deleted1 = es.deleteIndex(index);
        boolean deleted2 = es.deleteIndex(index);

        assertTrue(deleted1, "Existing index should be deleted");
        assertFalse(deleted2, "Deleting again should return false (not found)");
        assertFalse(validationClient.indices().exists(b -> b.index(index)).value());
    }

    @Test
    void createAlias_and_deleteAlias_work() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("idx_alias_" + UUID.randomUUID()).toLowerCase();
        String alias = ("alias_" + UUID.randomUUID()).toLowerCase();
        assertTrue(es.createIndex(index));

        // Create alias and verify it exists
        es.createAlias(index, alias);
        boolean aliasExists = validationClient.indices().existsAlias(b -> b.index(index).name(alias)).value();
        assertTrue(aliasExists, "Alias should exist for index");

        // Index a document via alias to ensure alias is usable for writes
        WebPageContent doc = new WebPageContent();
        String url = "https://alias.example/" + UUID.randomUUID();
        doc.setUrl(url);
        doc.setContents(List.of("via-alias"));
        String id = es.indexDocument(alias, doc);
        assertNotNull(id);

        GetResponse<WebPageContent> fetched = validationClient.get(g -> g.index(index).id(id), WebPageContent.class);
        assertTrue(fetched.found());
        assertEquals(url, fetched.source().getUrl());

        // Delete alias and verify it no longer exists
        es.deleteAlias(index, alias);
        boolean aliasExistsAfter = validationClient.indices().existsAlias(b -> b.index(index).name(alias)).value();
        assertFalse(aliasExistsAfter, "Alias should be removed from index");
    }

    @Test
    void createIndex_withJsonBody_appliesAlias() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String index = ("idx_body_" + UUID.randomUUID()).toLowerCase();
        String alias = ("alias_body_" + UUID.randomUUID()).toLowerCase();

        String json = "{" +
                "\"aliases\": {\"" + alias + "\": {}}" +
                "}";

        boolean created = es.createIndex(index, json);
        assertTrue(created, "Index should be created with JSON body");

        boolean aliasExists = validationClient.indices().existsAlias(b -> b.index(index).name(alias)).value();
        assertTrue(aliasExists, "Alias from JSON body should be applied to index");
    }

    @Test
    void createTemplate_patternsOnly_thenDelete() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String template = ("tmpl_" + UUID.randomUUID()).toLowerCase();
        List<String> patterns = List.of("logs-" + UUID.randomUUID().toString().substring(0, 8) + "-*");

        es.createTemplate(template, patterns, null);
        boolean exists = validationClient.indices().existsIndexTemplate(b -> b.name(template)).value();
        assertTrue(exists, "Template should exist after creation");

        es.deleteTemplate(template);
        boolean existsAfter = validationClient.indices().existsIndexTemplate(b -> b.name(template)).value();
        assertFalse(existsAfter, "Template should be deleted");
    }

    @Test
    void createTemplate_withJson_appliesAliasOnNewIndex() throws Exception {
        Assumptions.assumeTrue(dockerAvailable, "Docker is not available; skipping Elasticsearch tests");

        String template = ("tmpl_json_" + UUID.randomUUID()).toLowerCase();
        String prefix = ("data-" + UUID.randomUUID().toString().substring(0, 8)).toLowerCase();
        String alias = ("tmpl_alias_" + UUID.randomUUID()).toLowerCase();
        List<String> patterns = List.of(prefix + "-*");

        String templateJson = "{" +
                "\"index_patterns\": [\"" + patterns.get(0) + "\"]," +
                "\"template\": {" +
                "\"aliases\": {\"" + alias + "\": {}}" +
                "}" +
                "}";

        es.createTemplate(template, patterns, templateJson);
        boolean exists = validationClient.indices().existsIndexTemplate(b -> b.name(template)).value();
        assertTrue(exists, "Template should exist after creation");

        // Create an index that matches the template and verify alias is applied
        String index = prefix + "-0001";
        boolean created = es.createIndex(index);
        assertTrue(created);

        boolean aliasExists = validationClient.indices().existsAlias(b -> b.index(index).name(alias)).value();
        assertTrue(aliasExists, "Alias defined in template should be applied to the created index");

        // Cleanup template
        es.deleteTemplate(template);
    }
}
